<?php
/**
 * BackupconfigResponse
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * REST API for MySQL Cloud Service
 *
 * Use the REST API to manage MySQL Cloud Service instances
 *
 * OpenAPI spec version: 2017.01.06
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;

/**
 * BackupconfigResponse Class Doc Comment
 *
 * @category    Class */
 // @description The response body includes information about the backup configuration. If an update request was initiated and successfully completed, the response body shows the updated configuration.
/** 
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class BackupconfigResponse implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'backupconfig-response';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = array(
        'default_retention' => 'string',
        'full_backup_schedule' => '\Swagger\Client\Model\BackupSchedule',
        'incremental_backup_schedule' => '\Swagger\Client\Model\BackupSchedule',
        'scheduled_backups' => 'string',
        'extended_restore_types' => 'string',
        'last_backup_date' => 'string',
        'next_full_backup_date' => 'string',
        'next_incremental_backup_date' => 'string',
        'last_successful_cleanup_date' => 'string',
        'backup_destination' => 'string',
        'cloud_storage_container' => 'string',
        'cloud_storage_user' => 'string',
        'total_cloud_storage_container_used' => 'string',
        'total_cloud_storage_container_used_in_bytes' => 'string',
        'total_backup_volume_used' => 'string',
        'total_backup_volume_used_in_bytes' => 'string',
        'percent_backup_volume_used' => 'string'
    );

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = array(
        'default_retention' => 'defaultRetention',
        'full_backup_schedule' => 'fullBackupSchedule',
        'incremental_backup_schedule' => 'incrementalBackupSchedule',
        'scheduled_backups' => 'scheduledBackups',
        'extended_restore_types' => 'extendedRestoreTypes',
        'last_backup_date' => 'lastBackupDate',
        'next_full_backup_date' => 'nextFullBackupDate',
        'next_incremental_backup_date' => 'nextIncrementalBackupDate',
        'last_successful_cleanup_date' => 'lastSuccessfulCleanupDate',
        'backup_destination' => 'backupDestination',
        'cloud_storage_container' => 'cloudStorageContainer',
        'cloud_storage_user' => 'cloudStorageUser',
        'total_cloud_storage_container_used' => 'totalCloudStorageContainerUsed',
        'total_cloud_storage_container_used_in_bytes' => 'totalCloudStorageContainerUsedInBytes',
        'total_backup_volume_used' => 'totalBackupVolumeUsed',
        'total_backup_volume_used_in_bytes' => 'totalBackupVolumeUsedInBytes',
        'percent_backup_volume_used' => 'percentBackupVolumeUsed'
    );

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = array(
        'default_retention' => 'setDefaultRetention',
        'full_backup_schedule' => 'setFullBackupSchedule',
        'incremental_backup_schedule' => 'setIncrementalBackupSchedule',
        'scheduled_backups' => 'setScheduledBackups',
        'extended_restore_types' => 'setExtendedRestoreTypes',
        'last_backup_date' => 'setLastBackupDate',
        'next_full_backup_date' => 'setNextFullBackupDate',
        'next_incremental_backup_date' => 'setNextIncrementalBackupDate',
        'last_successful_cleanup_date' => 'setLastSuccessfulCleanupDate',
        'backup_destination' => 'setBackupDestination',
        'cloud_storage_container' => 'setCloudStorageContainer',
        'cloud_storage_user' => 'setCloudStorageUser',
        'total_cloud_storage_container_used' => 'setTotalCloudStorageContainerUsed',
        'total_cloud_storage_container_used_in_bytes' => 'setTotalCloudStorageContainerUsedInBytes',
        'total_backup_volume_used' => 'setTotalBackupVolumeUsed',
        'total_backup_volume_used_in_bytes' => 'setTotalBackupVolumeUsedInBytes',
        'percent_backup_volume_used' => 'setPercentBackupVolumeUsed'
    );

    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = array(
        'default_retention' => 'getDefaultRetention',
        'full_backup_schedule' => 'getFullBackupSchedule',
        'incremental_backup_schedule' => 'getIncrementalBackupSchedule',
        'scheduled_backups' => 'getScheduledBackups',
        'extended_restore_types' => 'getExtendedRestoreTypes',
        'last_backup_date' => 'getLastBackupDate',
        'next_full_backup_date' => 'getNextFullBackupDate',
        'next_incremental_backup_date' => 'getNextIncrementalBackupDate',
        'last_successful_cleanup_date' => 'getLastSuccessfulCleanupDate',
        'backup_destination' => 'getBackupDestination',
        'cloud_storage_container' => 'getCloudStorageContainer',
        'cloud_storage_user' => 'getCloudStorageUser',
        'total_cloud_storage_container_used' => 'getTotalCloudStorageContainerUsed',
        'total_cloud_storage_container_used_in_bytes' => 'getTotalCloudStorageContainerUsedInBytes',
        'total_backup_volume_used' => 'getTotalBackupVolumeUsed',
        'total_backup_volume_used_in_bytes' => 'getTotalBackupVolumeUsedInBytes',
        'percent_backup_volume_used' => 'getPercentBackupVolumeUsed'
    );

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = array();

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['default_retention'] = isset($data['default_retention']) ? $data['default_retention'] : null;
        $this->container['full_backup_schedule'] = isset($data['full_backup_schedule']) ? $data['full_backup_schedule'] : null;
        $this->container['incremental_backup_schedule'] = isset($data['incremental_backup_schedule']) ? $data['incremental_backup_schedule'] : null;
        $this->container['scheduled_backups'] = isset($data['scheduled_backups']) ? $data['scheduled_backups'] : null;
        $this->container['extended_restore_types'] = isset($data['extended_restore_types']) ? $data['extended_restore_types'] : null;
        $this->container['last_backup_date'] = isset($data['last_backup_date']) ? $data['last_backup_date'] : null;
        $this->container['next_full_backup_date'] = isset($data['next_full_backup_date']) ? $data['next_full_backup_date'] : null;
        $this->container['next_incremental_backup_date'] = isset($data['next_incremental_backup_date']) ? $data['next_incremental_backup_date'] : null;
        $this->container['last_successful_cleanup_date'] = isset($data['last_successful_cleanup_date']) ? $data['last_successful_cleanup_date'] : null;
        $this->container['backup_destination'] = isset($data['backup_destination']) ? $data['backup_destination'] : null;
        $this->container['cloud_storage_container'] = isset($data['cloud_storage_container']) ? $data['cloud_storage_container'] : null;
        $this->container['cloud_storage_user'] = isset($data['cloud_storage_user']) ? $data['cloud_storage_user'] : null;
        $this->container['total_cloud_storage_container_used'] = isset($data['total_cloud_storage_container_used']) ? $data['total_cloud_storage_container_used'] : null;
        $this->container['total_cloud_storage_container_used_in_bytes'] = isset($data['total_cloud_storage_container_used_in_bytes']) ? $data['total_cloud_storage_container_used_in_bytes'] : null;
        $this->container['total_backup_volume_used'] = isset($data['total_backup_volume_used']) ? $data['total_backup_volume_used'] : null;
        $this->container['total_backup_volume_used_in_bytes'] = isset($data['total_backup_volume_used_in_bytes']) ? $data['total_backup_volume_used_in_bytes'] : null;
        $this->container['percent_backup_volume_used'] = isset($data['percent_backup_volume_used']) ? $data['percent_backup_volume_used'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = array();
        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        return true;
    }


    /**
     * Gets default_retention
     * @return string
     */
    public function getDefaultRetention()
    {
        return $this->container['default_retention'];
    }

    /**
     * Sets default_retention
     * @param string $default_retention Number of days incremental backups and full on-demand backups are retained. If set to <code>null</code>, backups are retained indefinitely or until you manually delete them.<p>Full scheduled backups are retained until their last related incremental backup is no longer available, if any.
     * @return $this
     */
    public function setDefaultRetention($default_retention)
    {
        $this->container['default_retention'] = $default_retention;

        return $this;
    }

    /**
     * Gets full_backup_schedule
     * @return \Swagger\Client\Model\BackupSchedule
     */
    public function getFullBackupSchedule()
    {
        return $this->container['full_backup_schedule'];
    }

    /**
     * Sets full_backup_schedule
     * @param \Swagger\Client\Model\BackupSchedule $full_backup_schedule
     * @return $this
     */
    public function setFullBackupSchedule($full_backup_schedule)
    {
        $this->container['full_backup_schedule'] = $full_backup_schedule;

        return $this;
    }

    /**
     * Gets incremental_backup_schedule
     * @return \Swagger\Client\Model\BackupSchedule
     */
    public function getIncrementalBackupSchedule()
    {
        return $this->container['incremental_backup_schedule'];
    }

    /**
     * Sets incremental_backup_schedule
     * @param \Swagger\Client\Model\BackupSchedule $incremental_backup_schedule
     * @return $this
     */
    public function setIncrementalBackupSchedule($incremental_backup_schedule)
    {
        $this->container['incremental_backup_schedule'] = $incremental_backup_schedule;

        return $this;
    }

    /**
     * Gets scheduled_backups
     * @return string
     */
    public function getScheduledBackups()
    {
        return $this->container['scheduled_backups'];
    }

    /**
     * Sets scheduled_backups
     * @param string $scheduled_backups Type of scheduled backups. Only value is <code>ALL</code>. This means both full and incremental scheduled backups are enabled.
     * @return $this
     */
    public function setScheduledBackups($scheduled_backups)
    {
        $this->container['scheduled_backups'] = $scheduled_backups;

        return $this;
    }

    /**
     * Gets extended_restore_types
     * @return string
     */
    public function getExtendedRestoreTypes()
    {
        return $this->container['extended_restore_types'];
    }

    /**
     * Sets extended_restore_types
     * @param string $extended_restore_types Only value is <code>pit</code>. This means that point-in-time restoration is also supported, in addition to restoration by using a backup ID.
     * @return $this
     */
    public function setExtendedRestoreTypes($extended_restore_types)
    {
        $this->container['extended_restore_types'] = $extended_restore_types;

        return $this;
    }

    /**
     * Gets last_backup_date
     * @return string
     */
    public function getLastBackupDate()
    {
        return $this->container['last_backup_date'];
    }

    /**
     * Sets last_backup_date
     * @param string $last_backup_date Date and time that the last backup completed.<p><b>Note:</b> If there have been no backups, this attribute is omitted.
     * @return $this
     */
    public function setLastBackupDate($last_backup_date)
    {
        $this->container['last_backup_date'] = $last_backup_date;

        return $this;
    }

    /**
     * Gets next_full_backup_date
     * @return string
     */
    public function getNextFullBackupDate()
    {
        return $this->container['next_full_backup_date'];
    }

    /**
     * Sets next_full_backup_date
     * @param string $next_full_backup_date Scheduled date and time for next full backup.
     * @return $this
     */
    public function setNextFullBackupDate($next_full_backup_date)
    {
        $this->container['next_full_backup_date'] = $next_full_backup_date;

        return $this;
    }

    /**
     * Gets next_incremental_backup_date
     * @return string
     */
    public function getNextIncrementalBackupDate()
    {
        return $this->container['next_incremental_backup_date'];
    }

    /**
     * Sets next_incremental_backup_date
     * @param string $next_incremental_backup_date Scheduled date and time for next incremental backup.
     * @return $this
     */
    public function setNextIncrementalBackupDate($next_incremental_backup_date)
    {
        $this->container['next_incremental_backup_date'] = $next_incremental_backup_date;

        return $this;
    }

    /**
     * Gets last_successful_cleanup_date
     * @return string
     */
    public function getLastSuccessfulCleanupDate()
    {
        return $this->container['last_successful_cleanup_date'];
    }

    /**
     * Sets last_successful_cleanup_date
     * @param string $last_successful_cleanup_date Date and time that the last successful cleanup job completed. The cleanup job is run after the scheduled backup for the day is completed. The cleanup job purges old records, deletes expired backups. If there have been no cleanups, this attribute is omitted.
     * @return $this
     */
    public function setLastSuccessfulCleanupDate($last_successful_cleanup_date)
    {
        $this->container['last_successful_cleanup_date'] = $last_successful_cleanup_date;

        return $this;
    }

    /**
     * Gets backup_destination
     * @return string
     */
    public function getBackupDestination()
    {
        return $this->container['backup_destination'];
    }

    /**
     * Sets backup_destination
     * @param string $backup_destination Location of the backups; either <code>BOTH</code> (which means Disk and Oracle Storage Cloud Service Container) or <code>NONE</code>.
     * @return $this
     */
    public function setBackupDestination($backup_destination)
    {
        $this->container['backup_destination'] = $backup_destination;

        return $this;
    }

    /**
     * Gets cloud_storage_container
     * @return string
     */
    public function getCloudStorageContainer()
    {
        return $this->container['cloud_storage_container'];
    }

    /**
     * Sets cloud_storage_container
     * @param string $cloud_storage_container Name of the Oracle Storage Cloud Service container that is used to store backups.
     * @return $this
     */
    public function setCloudStorageContainer($cloud_storage_container)
    {
        $this->container['cloud_storage_container'] = $cloud_storage_container;

        return $this;
    }

    /**
     * Gets cloud_storage_user
     * @return string
     */
    public function getCloudStorageUser()
    {
        return $this->container['cloud_storage_user'];
    }

    /**
     * Sets cloud_storage_user
     * @param string $cloud_storage_user User name to access the specified Oracle Storage Cloud Service container.
     * @return $this
     */
    public function setCloudStorageUser($cloud_storage_user)
    {
        $this->container['cloud_storage_user'] = $cloud_storage_user;

        return $this;
    }

    /**
     * Gets total_cloud_storage_container_used
     * @return string
     */
    public function getTotalCloudStorageContainerUsed()
    {
        return $this->container['total_cloud_storage_container_used'];
    }

    /**
     * Sets total_cloud_storage_container_used
     * @param string $total_cloud_storage_container_used Total amount, in MBs, of the Storage Cloud Service container space that is currently in use.
     * @return $this
     */
    public function setTotalCloudStorageContainerUsed($total_cloud_storage_container_used)
    {
        $this->container['total_cloud_storage_container_used'] = $total_cloud_storage_container_used;

        return $this;
    }

    /**
     * Gets total_cloud_storage_container_used_in_bytes
     * @return string
     */
    public function getTotalCloudStorageContainerUsedInBytes()
    {
        return $this->container['total_cloud_storage_container_used_in_bytes'];
    }

    /**
     * Sets total_cloud_storage_container_used_in_bytes
     * @param string $total_cloud_storage_container_used_in_bytes Total amount, in Bytes, of the Storage Cloud Service container space that is currently in use.
     * @return $this
     */
    public function setTotalCloudStorageContainerUsedInBytes($total_cloud_storage_container_used_in_bytes)
    {
        $this->container['total_cloud_storage_container_used_in_bytes'] = $total_cloud_storage_container_used_in_bytes;

        return $this;
    }

    /**
     * Gets total_backup_volume_used
     * @return string
     */
    public function getTotalBackupVolumeUsed()
    {
        return $this->container['total_backup_volume_used'];
    }

    /**
     * Sets total_backup_volume_used
     * @param string $total_backup_volume_used Total amount, in MBs, of the backup volume that is currently in use.
     * @return $this
     */
    public function setTotalBackupVolumeUsed($total_backup_volume_used)
    {
        $this->container['total_backup_volume_used'] = $total_backup_volume_used;

        return $this;
    }

    /**
     * Gets total_backup_volume_used_in_bytes
     * @return string
     */
    public function getTotalBackupVolumeUsedInBytes()
    {
        return $this->container['total_backup_volume_used_in_bytes'];
    }

    /**
     * Sets total_backup_volume_used_in_bytes
     * @param string $total_backup_volume_used_in_bytes Total amount, in Bytes, of the backup volume that is currently in use.
     * @return $this
     */
    public function setTotalBackupVolumeUsedInBytes($total_backup_volume_used_in_bytes)
    {
        $this->container['total_backup_volume_used_in_bytes'] = $total_backup_volume_used_in_bytes;

        return $this;
    }

    /**
     * Gets percent_backup_volume_used
     * @return string
     */
    public function getPercentBackupVolumeUsed()
    {
        return $this->container['percent_backup_volume_used'];
    }

    /**
     * Sets percent_backup_volume_used
     * @param string $percent_backup_volume_used Total percent of the backup volume that is currently in use.
     * @return $this
     */
    public function setPercentBackupVolumeUsed($percent_backup_volume_used)
    {
        $this->container['percent_backup_volume_used'] = $percent_backup_volume_used;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


