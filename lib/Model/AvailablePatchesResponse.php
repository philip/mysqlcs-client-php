<?php
/**
 * AvailablePatchesResponse
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * REST API for MySQL Cloud Service
 *
 * Use the REST API to manage MySQL Cloud Service instances
 *
 * OpenAPI spec version: 2017.01.06
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;

/**
 * AvailablePatchesResponse Class Doc Comment
 *
 * @category    Class */
 // @description The response body contains information about the available patches.
/** 
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class AvailablePatchesResponse implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'available-patches-response';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = array(
        'available_patch_gui_metadata' => '\Swagger\Client\Model\AvailablepatchesresponseAvailablePatchGuiMetadata',
        'patch_id' => 'string',
        'patch_number' => 'string',
        'patch_category' => 'string',
        'patch_severity' => 'string',
        'includes_config_upgrade' => 'bool',
        'patch_description' => 'string',
        'patch_release_url' => 'string',
        'service_type' => 'string',
        'service_version' => 'string',
        'release_date' => 'string',
        'entry_date' => 'string',
        'entry_user_id' => 'string',
        'component_patches' => '\Swagger\Client\Model\ComponentPatch[]',
        'patch_components' => '\Swagger\Client\Model\PatchComponent[]',
        'patch_type' => 'string',
        'requires_restart' => 'bool',
        'service_type_versions' => 'string',
        'is_deleted' => 'bool',
        'is_customer_visible' => 'bool',
        'is_auto_apply' => 'bool',
        'induce_down_time' => 'bool',
        'display_name' => 'string',
        'meta_version' => 'string',
        'supported_strategy' => 'string',
        'release_version' => 'string',
        'patch_custom_actions' => 'string[]'
    );

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = array(
        'available_patch_gui_metadata' => 'availablePatchGuiMetadata',
        'patch_id' => 'patchId',
        'patch_number' => 'patchNumber',
        'patch_category' => 'patchCategory',
        'patch_severity' => 'patchSeverity',
        'includes_config_upgrade' => 'includesConfigUpgrade',
        'patch_description' => 'patchDescription',
        'patch_release_url' => 'patchReleaseUrl',
        'service_type' => 'serviceType',
        'service_version' => 'serviceVersion',
        'release_date' => 'releaseDate',
        'entry_date' => 'entryDate',
        'entry_user_id' => 'entryUserId',
        'component_patches' => 'componentPatches',
        'patch_components' => 'patchComponents',
        'patch_type' => 'patchType',
        'requires_restart' => 'requiresRestart',
        'service_type_versions' => 'serviceTypeVersions',
        'is_deleted' => 'isDeleted',
        'is_customer_visible' => 'isCustomerVisible',
        'is_auto_apply' => 'isAutoApply',
        'induce_down_time' => 'induceDownTime',
        'display_name' => 'displayName',
        'meta_version' => 'metaVersion',
        'supported_strategy' => 'supportedStrategy',
        'release_version' => 'releaseVersion',
        'patch_custom_actions' => 'patchCustomActions'
    );

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = array(
        'available_patch_gui_metadata' => 'setAvailablePatchGuiMetadata',
        'patch_id' => 'setPatchId',
        'patch_number' => 'setPatchNumber',
        'patch_category' => 'setPatchCategory',
        'patch_severity' => 'setPatchSeverity',
        'includes_config_upgrade' => 'setIncludesConfigUpgrade',
        'patch_description' => 'setPatchDescription',
        'patch_release_url' => 'setPatchReleaseUrl',
        'service_type' => 'setServiceType',
        'service_version' => 'setServiceVersion',
        'release_date' => 'setReleaseDate',
        'entry_date' => 'setEntryDate',
        'entry_user_id' => 'setEntryUserId',
        'component_patches' => 'setComponentPatches',
        'patch_components' => 'setPatchComponents',
        'patch_type' => 'setPatchType',
        'requires_restart' => 'setRequiresRestart',
        'service_type_versions' => 'setServiceTypeVersions',
        'is_deleted' => 'setIsDeleted',
        'is_customer_visible' => 'setIsCustomerVisible',
        'is_auto_apply' => 'setIsAutoApply',
        'induce_down_time' => 'setInduceDownTime',
        'display_name' => 'setDisplayName',
        'meta_version' => 'setMetaVersion',
        'supported_strategy' => 'setSupportedStrategy',
        'release_version' => 'setReleaseVersion',
        'patch_custom_actions' => 'setPatchCustomActions'
    );

    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = array(
        'available_patch_gui_metadata' => 'getAvailablePatchGuiMetadata',
        'patch_id' => 'getPatchId',
        'patch_number' => 'getPatchNumber',
        'patch_category' => 'getPatchCategory',
        'patch_severity' => 'getPatchSeverity',
        'includes_config_upgrade' => 'getIncludesConfigUpgrade',
        'patch_description' => 'getPatchDescription',
        'patch_release_url' => 'getPatchReleaseUrl',
        'service_type' => 'getServiceType',
        'service_version' => 'getServiceVersion',
        'release_date' => 'getReleaseDate',
        'entry_date' => 'getEntryDate',
        'entry_user_id' => 'getEntryUserId',
        'component_patches' => 'getComponentPatches',
        'patch_components' => 'getPatchComponents',
        'patch_type' => 'getPatchType',
        'requires_restart' => 'getRequiresRestart',
        'service_type_versions' => 'getServiceTypeVersions',
        'is_deleted' => 'getIsDeleted',
        'is_customer_visible' => 'getIsCustomerVisible',
        'is_auto_apply' => 'getIsAutoApply',
        'induce_down_time' => 'getInduceDownTime',
        'display_name' => 'getDisplayName',
        'meta_version' => 'getMetaVersion',
        'supported_strategy' => 'getSupportedStrategy',
        'release_version' => 'getReleaseVersion',
        'patch_custom_actions' => 'getPatchCustomActions'
    );

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = array();

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['available_patch_gui_metadata'] = isset($data['available_patch_gui_metadata']) ? $data['available_patch_gui_metadata'] : null;
        $this->container['patch_id'] = isset($data['patch_id']) ? $data['patch_id'] : null;
        $this->container['patch_number'] = isset($data['patch_number']) ? $data['patch_number'] : null;
        $this->container['patch_category'] = isset($data['patch_category']) ? $data['patch_category'] : null;
        $this->container['patch_severity'] = isset($data['patch_severity']) ? $data['patch_severity'] : null;
        $this->container['includes_config_upgrade'] = isset($data['includes_config_upgrade']) ? $data['includes_config_upgrade'] : null;
        $this->container['patch_description'] = isset($data['patch_description']) ? $data['patch_description'] : null;
        $this->container['patch_release_url'] = isset($data['patch_release_url']) ? $data['patch_release_url'] : null;
        $this->container['service_type'] = isset($data['service_type']) ? $data['service_type'] : null;
        $this->container['service_version'] = isset($data['service_version']) ? $data['service_version'] : null;
        $this->container['release_date'] = isset($data['release_date']) ? $data['release_date'] : null;
        $this->container['entry_date'] = isset($data['entry_date']) ? $data['entry_date'] : null;
        $this->container['entry_user_id'] = isset($data['entry_user_id']) ? $data['entry_user_id'] : null;
        $this->container['component_patches'] = isset($data['component_patches']) ? $data['component_patches'] : null;
        $this->container['patch_components'] = isset($data['patch_components']) ? $data['patch_components'] : null;
        $this->container['patch_type'] = isset($data['patch_type']) ? $data['patch_type'] : null;
        $this->container['requires_restart'] = isset($data['requires_restart']) ? $data['requires_restart'] : null;
        $this->container['service_type_versions'] = isset($data['service_type_versions']) ? $data['service_type_versions'] : null;
        $this->container['is_deleted'] = isset($data['is_deleted']) ? $data['is_deleted'] : null;
        $this->container['is_customer_visible'] = isset($data['is_customer_visible']) ? $data['is_customer_visible'] : null;
        $this->container['is_auto_apply'] = isset($data['is_auto_apply']) ? $data['is_auto_apply'] : null;
        $this->container['induce_down_time'] = isset($data['induce_down_time']) ? $data['induce_down_time'] : null;
        $this->container['display_name'] = isset($data['display_name']) ? $data['display_name'] : null;
        $this->container['meta_version'] = isset($data['meta_version']) ? $data['meta_version'] : null;
        $this->container['supported_strategy'] = isset($data['supported_strategy']) ? $data['supported_strategy'] : null;
        $this->container['release_version'] = isset($data['release_version']) ? $data['release_version'] : null;
        $this->container['patch_custom_actions'] = isset($data['patch_custom_actions']) ? $data['patch_custom_actions'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = array();
        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        return true;
    }


    /**
     * Gets available_patch_gui_metadata
     * @return \Swagger\Client\Model\AvailablepatchesresponseAvailablePatchGuiMetadata
     */
    public function getAvailablePatchGuiMetadata()
    {
        return $this->container['available_patch_gui_metadata'];
    }

    /**
     * Sets available_patch_gui_metadata
     * @param \Swagger\Client\Model\AvailablepatchesresponseAvailablePatchGuiMetadata $available_patch_gui_metadata
     * @return $this
     */
    public function setAvailablePatchGuiMetadata($available_patch_gui_metadata)
    {
        $this->container['available_patch_gui_metadata'] = $available_patch_gui_metadata;

        return $this;
    }

    /**
     * Gets patch_id
     * @return string
     */
    public function getPatchId()
    {
        return $this->container['patch_id'];
    }

    /**
     * Sets patch_id
     * @param string $patch_id Patch ID.
     * @return $this
     */
    public function setPatchId($patch_id)
    {
        $this->container['patch_id'] = $patch_id;

        return $this;
    }

    /**
     * Gets patch_number
     * @return string
     */
    public function getPatchNumber()
    {
        return $this->container['patch_number'];
    }

    /**
     * Sets patch_number
     * @param string $patch_number Patch number.
     * @return $this
     */
    public function setPatchNumber($patch_number)
    {
        $this->container['patch_number'] = $patch_number;

        return $this;
    }

    /**
     * Gets patch_category
     * @return string
     */
    public function getPatchCategory()
    {
        return $this->container['patch_category'];
    }

    /**
     * Sets patch_category
     * @param string $patch_category Category of the patch. For example: <code>General</code>, <code>Upgrade</code>, <code>Multiple</code>, <code>Security</code>, and so on.
     * @return $this
     */
    public function setPatchCategory($patch_category)
    {
        $this->container['patch_category'] = $patch_category;

        return $this;
    }

    /**
     * Gets patch_severity
     * @return string
     */
    public function getPatchSeverity()
    {
        return $this->container['patch_severity'];
    }

    /**
     * Sets patch_severity
     * @param string $patch_severity Severity of the patch. For example <code>Normal</code>, <code>Mandatory</code>, <code>Recommended</code>, and so on.
     * @return $this
     */
    public function setPatchSeverity($patch_severity)
    {
        $this->container['patch_severity'] = $patch_severity;

        return $this;
    }

    /**
     * Gets includes_config_upgrade
     * @return bool
     */
    public function getIncludesConfigUpgrade()
    {
        return $this->container['includes_config_upgrade'];
    }

    /**
     * Sets includes_config_upgrade
     * @param bool $includes_config_upgrade Flag that indicates whether the patch includes a configuration upgrade.
     * @return $this
     */
    public function setIncludesConfigUpgrade($includes_config_upgrade)
    {
        $this->container['includes_config_upgrade'] = $includes_config_upgrade;

        return $this;
    }

    /**
     * Gets patch_description
     * @return string
     */
    public function getPatchDescription()
    {
        return $this->container['patch_description'];
    }

    /**
     * Sets patch_description
     * @param string $patch_description Description of the patch.
     * @return $this
     */
    public function setPatchDescription($patch_description)
    {
        $this->container['patch_description'] = $patch_description;

        return $this;
    }

    /**
     * Gets patch_release_url
     * @return string
     */
    public function getPatchReleaseUrl()
    {
        return $this->container['patch_release_url'];
    }

    /**
     * Sets patch_release_url
     * @param string $patch_release_url URL that provides more information about the patch.
     * @return $this
     */
    public function setPatchReleaseUrl($patch_release_url)
    {
        $this->container['patch_release_url'] = $patch_release_url;

        return $this;
    }

    /**
     * Gets service_type
     * @return string
     */
    public function getServiceType()
    {
        return $this->container['service_type'];
    }

    /**
     * Sets service_type
     * @param string $service_type Type of Oracle MySQL Cloud Service. For example: <code>MySQLCS</code>.
     * @return $this
     */
    public function setServiceType($service_type)
    {
        $this->container['service_type'] = $service_type;

        return $this;
    }

    /**
     * Gets service_version
     * @return string
     */
    public function getServiceVersion()
    {
        return $this->container['service_version'];
    }

    /**
     * Sets service_version
     * @param string $service_version Oracle MySQL Cloud Service instance version to which the patch can be applied. For example: <code>5.7</code>, <code>Any</code>, where <code>Any</code> indicates that the patch can be applied to any version.
     * @return $this
     */
    public function setServiceVersion($service_version)
    {
        $this->container['service_version'] = $service_version;

        return $this;
    }

    /**
     * Gets release_date
     * @return string
     */
    public function getReleaseDate()
    {
        return $this->container['release_date'];
    }

    /**
     * Sets release_date
     * @param string $release_date Date and time the patch is released.
     * @return $this
     */
    public function setReleaseDate($release_date)
    {
        $this->container['release_date'] = $release_date;

        return $this;
    }

    /**
     * Gets entry_date
     * @return string
     */
    public function getEntryDate()
    {
        return $this->container['entry_date'];
    }

    /**
     * Sets entry_date
     * @param string $entry_date Date and time the patch is created.
     * @return $this
     */
    public function setEntryDate($entry_date)
    {
        $this->container['entry_date'] = $entry_date;

        return $this;
    }

    /**
     * Gets entry_user_id
     * @return string
     */
    public function getEntryUserId()
    {
        return $this->container['entry_user_id'];
    }

    /**
     * Sets entry_user_id
     * @param string $entry_user_id Name of the user that created the patch.
     * @return $this
     */
    public function setEntryUserId($entry_user_id)
    {
        $this->container['entry_user_id'] = $entry_user_id;

        return $this;
    }

    /**
     * Gets component_patches
     * @return \Swagger\Client\Model\ComponentPatch[]
     */
    public function getComponentPatches()
    {
        return $this->container['component_patches'];
    }

    /**
     * Sets component_patches
     * @param \Swagger\Client\Model\ComponentPatch[] $component_patches Group the details of each patches in the component.
     * @return $this
     */
    public function setComponentPatches($component_patches)
    {
        $this->container['component_patches'] = $component_patches;

        return $this;
    }

    /**
     * Gets patch_components
     * @return \Swagger\Client\Model\PatchComponent[]
     */
    public function getPatchComponents()
    {
        return $this->container['patch_components'];
    }

    /**
     * Sets patch_components
     * @param \Swagger\Client\Model\PatchComponent[] $patch_components Group the details of the patch to be applied.
     * @return $this
     */
    public function setPatchComponents($patch_components)
    {
        $this->container['patch_components'] = $patch_components;

        return $this;
    }

    /**
     * Gets patch_type
     * @return string
     */
    public function getPatchType()
    {
        return $this->container['patch_type'];
    }

    /**
     * Sets patch_type
     * @param string $patch_type Patch type classification. For example, <code>Quarterly</Code>, <code>Security</Code>.
     * @return $this
     */
    public function setPatchType($patch_type)
    {
        $this->container['patch_type'] = $patch_type;

        return $this;
    }

    /**
     * Gets requires_restart
     * @return bool
     */
    public function getRequiresRestart()
    {
        return $this->container['requires_restart'];
    }

    /**
     * Sets requires_restart
     * @param bool $requires_restart Flag that indicates whether the patch requires a restart of the service instance.
     * @return $this
     */
    public function setRequiresRestart($requires_restart)
    {
        $this->container['requires_restart'] = $requires_restart;

        return $this;
    }

    /**
     * Gets service_type_versions
     * @return string
     */
    public function getServiceTypeVersions()
    {
        return $this->container['service_type_versions'];
    }

    /**
     * Sets service_type_versions
     * @param string $service_type_versions Oracle MySQL Cloud Service instance version to which the patch can be applied. For example: <code>5.7</code>, <code>Any</code>, where <code>Any</code> indicates that the patch can be applied to any version.
     * @return $this
     */
    public function setServiceTypeVersions($service_type_versions)
    {
        $this->container['service_type_versions'] = $service_type_versions;

        return $this;
    }

    /**
     * Gets is_deleted
     * @return bool
     */
    public function getIsDeleted()
    {
        return $this->container['is_deleted'];
    }

    /**
     * Sets is_deleted
     * @param bool $is_deleted Flag that indicates whether the patch has been deleted and is no longer available. The information about the patch is not removed from the list of available patches in order to maintain an historical record of all patches.
     * @return $this
     */
    public function setIsDeleted($is_deleted)
    {
        $this->container['is_deleted'] = $is_deleted;

        return $this;
    }

    /**
     * Gets is_customer_visible
     * @return bool
     */
    public function getIsCustomerVisible()
    {
        return $this->container['is_customer_visible'];
    }

    /**
     * Sets is_customer_visible
     * @param bool $is_customer_visible Flag that indicates whether the patch is visible to customer.
     * @return $this
     */
    public function setIsCustomerVisible($is_customer_visible)
    {
        $this->container['is_customer_visible'] = $is_customer_visible;

        return $this;
    }

    /**
     * Gets is_auto_apply
     * @return bool
     */
    public function getIsAutoApply()
    {
        return $this->container['is_auto_apply'];
    }

    /**
     * Sets is_auto_apply
     * @param bool $is_auto_apply Flag that indicates whether the patch can be applied automatically.
     * @return $this
     */
    public function setIsAutoApply($is_auto_apply)
    {
        $this->container['is_auto_apply'] = $is_auto_apply;

        return $this;
    }

    /**
     * Gets induce_down_time
     * @return bool
     */
    public function getInduceDownTime()
    {
        return $this->container['induce_down_time'];
    }

    /**
     * Sets induce_down_time
     * @param bool $induce_down_time Flag that indicates whether the patching induces a downtime of the service.
     * @return $this
     */
    public function setInduceDownTime($induce_down_time)
    {
        $this->container['induce_down_time'] = $induce_down_time;

        return $this;
    }

    /**
     * Gets display_name
     * @return string
     */
    public function getDisplayName()
    {
        return $this->container['display_name'];
    }

    /**
     * Sets display_name
     * @param string $display_name Display name of the patch.
     * @return $this
     */
    public function setDisplayName($display_name)
    {
        $this->container['display_name'] = $display_name;

        return $this;
    }

    /**
     * Gets meta_version
     * @return string
     */
    public function getMetaVersion()
    {
        return $this->container['meta_version'];
    }

    /**
     * Sets meta_version
     * @param string $meta_version The release version of metadata service manager.
     * @return $this
     */
    public function setMetaVersion($meta_version)
    {
        $this->container['meta_version'] = $meta_version;

        return $this;
    }

    /**
     * Gets supported_strategy
     * @return string
     */
    public function getSupportedStrategy()
    {
        return $this->container['supported_strategy'];
    }

    /**
     * Sets supported_strategy
     * @param string $supported_strategy Supported patching strategy. For example: <code>In Place</code>.
     * @return $this
     */
    public function setSupportedStrategy($supported_strategy)
    {
        $this->container['supported_strategy'] = $supported_strategy;

        return $this;
    }

    /**
     * Gets release_version
     * @return string
     */
    public function getReleaseVersion()
    {
        return $this->container['release_version'];
    }

    /**
     * Sets release_version
     * @param string $release_version Release version of the component in this patch.
     * @return $this
     */
    public function setReleaseVersion($release_version)
    {
        $this->container['release_version'] = $release_version;

        return $this;
    }

    /**
     * Gets patch_custom_actions
     * @return string[]
     */
    public function getPatchCustomActions()
    {
        return $this->container['patch_custom_actions'];
    }

    /**
     * Sets patch_custom_actions
     * @param string[] $patch_custom_actions List of customer actions during patching.
     * @return $this
     */
    public function setPatchCustomActions($patch_custom_actions)
    {
        $this->container['patch_custom_actions'] = $patch_custom_actions;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


